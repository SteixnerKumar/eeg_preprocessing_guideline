% This function is the pre-processing protocol for the EEG
% Involves the following parts
% 1.) Reading the file
% 2.) Downsampling
% 3.) cut the data between the start and end triggers
% 4.) Divide the data into two participants
% 5.) Checking for the Bridgeing
% 6.) Filtering
% 7.) Reject bad channels (and interpolate the good ones)
% 8.) Re-referencing
% cut into epoch, baseline correction
% 9.) Artifact correction using ICA (perform rank reduction before becauuse of interpolation)
% 10.)
%

%% add paths
% warning!!!!!!!!
% please change these accourding to your system setup
% eeglab
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b');
addpath(genpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/functions'));
removepath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/functions/octavefunc');
% eeglab plugins
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/plugins/');
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/plugins/amica1.5/');
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/plugins/clean_rawdata0.34/');
addpath(genpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/eeglab14_1_2b/plugins/tmullen-cleanline-696a7181b7d0/'));
% fieldtrip
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/fieldtrip-20220104/');
ft_defaults;
% SASICA toolbox
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/SASICA-master');
% sk (personal) utilities
addpath('/projects/crunchie/kumar/.exor/kumar_working_directory/matlab/work/sk_codes/sk_utilities');
% behavioral data folder (if needed)
addpath(strcat(pwd,'/data/behavioural_data'));
% eeg data folder (if needed)
addpath(strcat(pwd,'/data/eeg_data'));
% extra functions
addpath(strcat(pwd,'/eeg_preprocessing_guideline'));
%
clear;
clc;

%% basic required parameters
% tcg.version = 'sender'; % 'sender', 'receiver'
% tcg.session = 1; % session number is exists
tcg.sub_num = 13; % participant number id



% autogeneration of names
tcg.sub_S = strcat('S',num2str(tcg.sub_num)); % sender behavior filename is autogenerated
tcg.sub_R = strcat('R',num2str(tcg.sub_num));% receiver behavior filename is autogenerated
tcg.eeg_data = strcat('data',num2str(tcg.sub_num)); % eeg filename is autogenerated
%
wanted.save = 1;
wanted.photo_diode_trigger_adjustment = 0; % '1' for yes, '0' for no
wanted.downsampling = 1; % '1' for yes, '0' for no
wanted.cut_start_end = 0; % '1' for yes, '0' for no
wanted.fs_new = 256;%512; % new sampling frequency
wanted.bridging_check = 1; % '1' for yes, '0' for no
wanted.filtering= 1; % '1' for yes, '0' for no (Please filter, else in ASR there is no clean section of data to choose from, hence error)
wanted.rereferencing = 1; % '1' for yes, '0' for no
wanted.clean_data = 1; % '1' for yes, '0' for no
wanted.ica = 1; % '1' for yes, '0' for no
wanted.ica_algorithm = 'amica'; % wanted.ica_algorithm = 'runica' or 'amica'
wanted.trials = 0;
wanted.plots = 1; % 1 to check the filter
plots_see_chan = 65;%64;%15; % the channel number to see


%% Logging
diary(strcat('log_tcg',strcat('_',datestr(now,'YYYYmmDD'),'_',datestr(now,'HHMMSS'),'_'),...
    '_vp',tcg.sub_S,'_vp',tcg.sub_R,'.txt'));
% print the default parameters for the log
clc;
disp('The file parameters : ');disp(tcg);fprintf('\n');
disp('The code parameters -  ''1'' for yes, ''0'' for no : ');disp(wanted);fprintf('\n');
try
    tic;
    % downsampling, band-pass, re-ref, artifact-correction, sectioning, baseline-correction
    %% Reading data
    fprintf('Loading the data ...\n ');
%     filename.eegdata = strcat('tt_',tt.version,'_session_',num2str(tt.session),'_vp',num2str(tt.sub_A),'_vp',num2str(tt.sub_B),'.bdf');
    filename.eegdata = strcat(tcg.eeg_data,'.bdf');
    
    data.both = ft_read_data(filename.eegdata);
    hdr.both = ft_read_header(filename.eegdata);
    events = ft_read_event(filename.eegdata);
    % the behavioral data
%     if ~strcmp(tt.version,'single')
%         tt.version = strcat('multi_',tt.version);
%     end
    filename.behavior_S = strcat(tcg.sub_S,'.mat');
    load(filename.behavior_S);behave_data.S = blocks;
    clear blocks
    filename.behavior_R = strcat(tcg.sub_R,'.mat');
    load(filename.behavior_R);behave_data.R = blocks;
    clear blocks
    fprintf('Data loaded.\n ');
    
    %% tiggers timing adjustment according to the photo diodes
    if wanted.photo_diode_trigger_adjustment
        fprintf('Adjusting the data according to the delays of the screens ...\n');
        % the diode_avg.default structure is important as it decides the
        % triggers that are adjusted, please make sure the names are exactly as in the behaviour files in ttsk.trig structure
        diode_avg.default.start_prediction = 28;
        diode_avg.default.start_choice = 27;
        diode_avg.default.start_evidence_other_player = 143;
        diode_avg.default.start_evidence_own = 185;
        %         diode_avg.default.end_choice = 10;
        % to get the trigger values
        events_trigger = events(strcmp({events.type}, 'STATUS'));
        byte.second = nan(1,size(events_trigger,2));
        for loop_triggers = 1:size(events_trigger,2)
            in_binary = dec2bin(events_trigger(loop_triggers).value,24)-'0';
            binary_usb = in_binary(9:16);
            byte.second(loop_triggers) = bin2dec(num2str(binary_usb));
        end
        % now here the avg of all the triggers
        % find all the positions of 210,220,230,240 in byte.second
        trig_cat = fieldnames(diode_avg.default);
        for loop_trig_cat = 1:numel(fieldnames(diode_avg.default))
            eval(string(strcat('trig_diode_location_def.',trig_cat(loop_trig_cat),' = find(byte.second==behave_data.S.ttsk.trig.',trig_cat(loop_trig_cat),') +1;')));
            eval(string(strcat('trig_diode_location.',trig_cat(loop_trig_cat),' = trig_diode_location_def.',trig_cat(loop_trig_cat),'(byte.second(trig_diode_location_def.',trig_cat(loop_trig_cat),')== 0);')));
            eval(string(strcat('trig_diode_location_def.',trig_cat(loop_trig_cat),' = trig_diode_location_def.',trig_cat(loop_trig_cat),'-1;')));
            eval(string(strcat('diode_sum.',trig_cat(loop_trig_cat),' = 0;')));
            eval(string(strcat('for loop_trig_diode_location = 1:length(trig_diode_location.',trig_cat(loop_trig_cat),');diode_sum.',trig_cat(loop_trig_cat),' = diode_sum.',trig_cat(loop_trig_cat)...
                ,' + (events_trigger(trig_diode_location.',trig_cat(loop_trig_cat),'(loop_trig_diode_location)).sample - events_trigger(trig_diode_location.',trig_cat(loop_trig_cat)...
                ,'(loop_trig_diode_location)-1).sample);end')));
            eval(string(strcat('diode_avg.',trig_cat(loop_trig_cat),' = floor(diode_sum.',trig_cat(loop_trig_cat),'/length(trig_diode_location.',trig_cat(loop_trig_cat),'));')));
        end
        % adjust the delay if trigger found
        for loop_trig_cat = 1:numel(fieldnames(diode_avg.default))
            eval(string(strcat('if ~isnan(diode_avg.',trig_cat(loop_trig_cat),');for loop_trig_diode_location = 1: length(trig_diode_location_def.',trig_cat(loop_trig_cat),');events_trigger(trig_diode_location_def.',...
                trig_cat(loop_trig_cat),'(loop_trig_diode_location)).sample = events_trigger(trig_diode_location_def.',trig_cat(loop_trig_cat),'(loop_trig_diode_location)).sample',...
                ' + diode_avg.',trig_cat(loop_trig_cat),';end;','fprintf(''adjusted the delay of : %s screen by %d points\n'',string(trig_cat(loop_trig_cat)),diode_avg.',trig_cat(loop_trig_cat),');',...
                'else;fprintf(''did not find the delay of : %s screen as no trigger found, therefore adjusting by average default value of: %d points\n'',string(trig_cat(loop_trig_cat)),diode_avg.default.',trig_cat(loop_trig_cat),');',...
                'for loop_trig_diode_location = 1: length(trig_diode_location_def.',trig_cat(loop_trig_cat),');events_trigger(trig_diode_location_def.',trig_cat(loop_trig_cat)...
                ,'(loop_trig_diode_location)).sample = events_trigger(trig_diode_location_def.',trig_cat(loop_trig_cat),'(loop_trig_diode_location)).sample'...
                ,' + diode_avg.default.',trig_cat(loop_trig_cat),';end;end;')));
        end
        %
        % Now important to put the event triggers back into the events for use
        % by other sections of this code.
        events(strcmp({events.type}, 'STATUS')) = events_trigger;
        %
        clear loop_trig_diode_location loop_triggers trig_diode_location_def trig_diode_location diode_sum
        clear diode_sum trig_diode_location
        clear in_binary loop_try binary_lsb binary_usb binary_third
        fprintf('Adjusting the data according to the delays of the screens ... Done.\n');
    else
        fprintf('Adjusting the data according to the delays of the screens not Done.\n ');
    end
    
    %% downsampling
    % maybe use the anti-aliasing low pass filter before the downsampling process (yet to be imnplemented)
    % downsample is needed to save the computation power and time --
    % needs to be done on the data, in the header and in the events.
    
    % In the data
    if wanted.downsampling
        fprintf('Downsampling the data by a factor of %d ...\n ',hdr.both.Fs/wanted.fs_new);
        if ~(floor(hdr.both.Fs/wanted.fs_new) == hdr.both.Fs/wanted.fs_new)
            error('new sampling rate needs to be a proper divisor of original sampling rate');
        end
        data_both_temp = NaN(size(data.both,1),ceil(size(data.both,2)/(hdr.both.Fs/wanted.fs_new))); % initialization of a temporary variable
        fprintf('individual channel-wise out of %d\n',hdr.both.nChans);
        for loop_chan = 1:hdr.both.nChans % filter loop as channel-wise downsampling will be done
            data_both_temp(loop_chan,:) = downsample(data.both(loop_chan,:),(hdr.both.Fs/wanted.fs_new));
            if (mod(loop_chan,30)==1) && (loop_chan~=1)  % max 30 channels to show in one line
                fprintf('\n ');
            end
            fprintf('%d ',loop_chan);
        end
        fprintf('\n ');
        % fprintf('Downsampling of the data done.\n ');
        data.both = data_both_temp;
        clear data_both_temp;
        % In the events
        for loop_markers = 1:length(strcmp('STATUS', {events.type}))
            if strcmp('STATUS', {events(loop_markers).type})
                events(loop_markers).sample = floor(events(loop_markers).sample/(hdr.both.Fs/wanted.fs_new));
            end
        end
        % In the header
        hdr.both.nSamples = ceil(hdr.both.nSamples/(hdr.both.Fs/wanted.fs_new));
        hdr.both.Fs = hdr.both.Fs/(hdr.both.Fs/wanted.fs_new);
        clear wanted.fs_new loop_chan loop_markers;
        fprintf('Downsampling of the data done.\n ');
    elseif wanted.downsampling==0
        fprintf('Downsampling not Done.\n');
    end
    
    %% Cut between the start and end
    if wanted.cut_start_end
        %
        fprintf('Cutting the data between the start and end of the experiment on the basis of the defined start and end triggers ...\n');
        % to get the trigger values
        trig.start = behave_data.S.ttsk.trig.start_experiment; % to cut the data start trigger
        trig.end = behave_data.S.ttsk.trig.end_experiment; % to cut the data end trigger
        %
        events_trigger = events(strcmp({events.type}, 'STATUS'));
        byte.second = nan(1,size(events_trigger,2));
        for loop_triggers = 1:size(events_trigger,2)
            in_binary = dec2bin(events_trigger(loop_triggers).value,24)-'0';
            binary_usb = in_binary(9:16);
            byte.second(loop_triggers) = bin2dec(num2str(binary_usb));
        end
        clear in_binary loop_try binary_lsb binary_usb binary_third
        % to get the start and the end triggers (tiger_task: start = 100, end  = 101)
        temp_start = find(byte.second == trig.start);
        temp_end = find(byte.second == trig.end);
        if isempty(temp_start)
            temp_start = 1;
            fprintf('no start trigger found hence using the starting of the recording as the start point\n');
        end
        if isempty(temp_end)
            temp_end = length(events_trigger);
            fprintf('no end trigger found hence using the end of the recording as the end point\n');
        end
        % to select the triggers only between the start and the end of the experiment
        % cut the events
        events_trigger = events_trigger(temp_start:temp_end);
        % cut the eeg potential data now
        data.both = data.both(:,events_trigger(1).sample:events_trigger(end).sample);
        % cut the header
        hdr.both.nSamples = size(data.both,2);
        clear temp_start temp_end loop_triggers byte
        %
        fprintf('Cutting the data between the start and end of the experiment on the basis of the defined start and end triggers ... Done.\n');
        %
    elseif wanted.downsampling==0
        fprintf('Cutting the data between the start and end of the experiment on the basis of the defined start and end triggers not Done.\n');
    end
    
    %% Cut into the two participants
    fprintf('Cutting the data into the two participants ...\n');
    temp_chans_S = nan(hdr.both.nChans,1);
    temp_chans_R = nan(hdr.both.nChans,1);
    for loop_chans = 1:hdr.both.nChans
        if (str2double(hdr.both.label{loop_chans}(1))==1) % first participant labels start with '1'
            temp_chans_S(loop_chans) = 1;
        elseif (str2double(hdr.both.label{loop_chans}(1))==2) % first participant labels start with '2'
            temp_chans_R(loop_chans) = 1;
        end
    end
    temp_chans_S = find(temp_chans_S==1);
    temp_chans_R = find(temp_chans_R==1);
    % setting header file for both participants
    hdr.S = hdr.both;
    hdr.R = hdr.both;
    hdr.S.label = hdr.both.label(temp_chans_S);
    hdr.R.label = hdr.both.label(temp_chans_R);
    hdr.S.nChans = length(temp_chans_S);
    hdr.R.nChans = length(temp_chans_R);
    hdr.S.chantype = hdr.both.chantype(temp_chans_S);
    hdr.R.chantype = hdr.both.chantype(temp_chans_R);
    hdr.S.chanunit = hdr.both.chanunit(temp_chans_S);
    hdr.R.chanunit = hdr.both.chanunit(temp_chans_R);
    % Cutting the eeg potential data into the participants
    data.S = data.both(temp_chans_S,:);
    data.R = data.both(temp_chans_R,:);
    clear temp_chans_A temp_chans_B loop_chans
    fprintf('Cutting the data into the two participants ... Done.\n');
    
    %% Check for Bridging
    S.channels_to_remove_bridge = zeros(hdr.S.nChans,1);
    R.channels_to_remove_bridge = zeros(hdr.R.nChans,1);
    if wanted.bridging_check
        S.channels_to_remove_bridge = zeros(hdr.S.nChans,1);
        R.channels_to_remove_bridge = zeros(hdr.R.nChans,1);
        %  [EB_out ,ED_out] = eBridge(ALLEEG(2),{'1-EXG1','1-EXG2','1-EXG3','1-EXG4','1-EXG5','1-EXG6','1-EXG7','1-EXG8','2-EXG1','2-EXG2','2-EXG3','2-EXG4','2-EXG5','2-EXG6','2-EXG7','2-EXG8','Status'});
        fprintf('Checking for bridging ...\n');
        % arranging data for the use by ebridge algorithm
%         S.EEG_wrapper.chanlocs = struct('labels',hdr.S.label);
        S.EEG_wrapper.chanlocs = readlocs( 'before_ebridge_128 EQ A on MNI Colin27 with ABCD labels for BESA.sfp','filetype','sfp');
%         S.EEG_wrapper.data = data.S;
        S.EEG_wrapper.data = data.S(1:numel(S.EEG_wrapper.chanlocs),:);
        S.EEG_wrapper.srate = hdr.S.Fs;
%         R.EEG_wrapper.chanlocs = struct('labels',hdr.R.label);
        R.EEG_wrapper.chanlocs = readlocs( 'before_ebridge_128 EQ A on MNI Colin27 with ABCD labels for BESA.sfp','filetype','sfp');
%         R.EEG_wrapper.data = data.R;
        R.EEG_wrapper.data = data.R(1:numel(R.EEG_wrapper.chanlocs),:);
        R.EEG_wrapper.srate = hdr.R.Fs;
        % sk_ebridge is without plots
        fprintf('Checking for bridges in the first participant ...\n');
        [S.EB_out ,S.ED_out] = sk_eBridge(S.EEG_wrapper,{'1-EXG1','1-EXG2','1-EXG3','1-EXG4','1-EXG5','1-EXG6','1-EXG7','1-EXG8', ...
            '2-EXG1','2-EXG2','2-EXG3','2-EXG4','2-EXG5','2-EXG6','2-EXG7','2-EXG8','Status'});
        fprintf('Checking for bridges in the second participant ...\n');
        [R.EB_out ,R.ED_out] = sk_eBridge(R.EEG_wrapper,{'1-EXG1','1-EXG2','1-EXG3','1-EXG4','1-EXG5','1-EXG6','1-EXG7','1-EXG8', ...
            '2-EXG1','2-EXG2','2-EXG3','2-EXG4','2-EXG5','2-EXG6','2-EXG7','2-EXG8','Status'});
        % clear A B
        fprintf('Checking for bridging ... Done.\n');
        % remove the bridged channels
        fprintf('Marking the bridged channels for both participants ...\n');
        % data.S(S.EB_out.Bridged.Indices,:) = [];
        % data.R(R.EB_out.Bridged.Indices,:) = [];
        S.channels_to_remove_bridge(S.EB_out.Bridged.Indices,1) = true;
        R.channels_to_remove_bridge(R.EB_out.Bridged.Indices,1) = true;
        fprintf('Marking the bridged channels for both participants ... Done.\n');
    else
        fprintf('Bridging check not done.\n');
    end
    
    
    %% Filtering (highpass, then lowpass)
    % implementation of the line noise filter
    % cleanline(EEG, 'LineFrequencies',[50 100]);
    % [EEG.S, Sorig, Sclean, f, amps, freqs, g] = cleanline('EEG',EEG.S, 'LineFrequencies',[50 100]);
    % pre filter plot
    if wanted.filtering
        fprintf('Filtering the line noise out for both participants ...\n');
        if wanted.plots
            figure;
            subplot(3,2,1);plot(data.S(plots_see_chan,:));title('The unfiltered data time');
            [XFreqRange, YAmplitude] = sk_dofft(data.S(plots_see_chan,:), hdr.S.Fs, 4);
            subplot(3,2,2);plot(XFreqRange, YAmplitude);axis([5 150 -0.2 1.5]);title('The unfiltered data freq');
            clear XFreqRange YAmplitude;
        end
        EEG.S.data = data.S;
        EEG.S.icawinv = [];
        EEG.S.srate = hdr.both.Fs;
        EEG.S.nbchan = size(data.S,1);
        EEG.S.trials = 1; % no trials
        EEG.S.pnts = size(data.S,2);
        EEG.R.data = data.R;
        EEG.R.icawinv = [];
        EEG.R.srate = hdr.both.Fs;
        EEG.R.nbchan = size(data.R,1);
        EEG.R.trials = 1; % no trials
        EEG.R.pnts = size(data.R,2);
        % [EEG.S, ~, ~, ~, ~, , ~] = cleanline('EEG',EEG.S, 'LineFrequencies',[50 100]);
        [EEG.S, ~, ~, ~, ~, ~, ~] = cleanline('EEG',EEG.S, 'LineFrequencies',[50 100],'ScanForLines',1,'LineAlpha',1,'Bandwidth',1);
        [EEG.R, ~, ~, ~, ~, ~, ~] = cleanline('EEG',EEG.R, 'LineFrequencies',[50 100],'ScanForLines',1,'LineAlpha',1,'Bandwidth',1);
        data.Sf = EEG.S.data;
        data.Rf = EEG.R.data;
        clear EEG
        % post line filter plot
        if wanted.plots
            subplot(3,2,3);plot(data.Sf(plots_see_chan,:));title('The filtered data time (after line filter)');
            [XFreqRange, YAmplitude] = sk_dofft(data.Sf(plots_see_chan,:), hdr.S.Fs, 4);
            subplot(3,2,4);plot(XFreqRange, YAmplitude);axis([5 150 -0.2 1.5]);title('The filtered data freq (after line filter)');
            clear XFreqRange YAmplitude;
        end
        fprintf('Filtering the line noise out for both participants ... Done.\n');
        %
        %
        fprintf('Using low-pass filtering for both participants ...\n');
        filter.type = 'but'; % the filter type ('but' is for butterworth)
        filter.dir = 'twopass'; % the filter direction ('twopass' is default for both direction)
        filter.order = 4; % filter order number
        filter.lowpass = 90; % in Hz
        filter.highpass = 1; % in Hz
        fprintf('Using filter: %s, with direction: %s, order: %d, in range: %d - %d Hz.\n',filter.type,filter.dir,filter.order,filter.highpass,filter.lowpass);
        [data.Sf] = ft_preproc_bandpassfilter(data.Sf, hdr.S.Fs, [filter.highpass filter.lowpass], filter.order, filter.type, filter.dir);
        [data.Rf] = ft_preproc_bandpassfilter(data.Rf, hdr.R.Fs, [filter.highpass filter.lowpass], filter.order, filter.type, filter.dir);
        fprintf('Using low-pass filtering for both participants ... Done.\n');
        % post all filter plot
        if wanted.plots
            subplot(3,2,5);plot(data.Sf(plots_see_chan,:));title('The filtered data time (after bandpass)');
            [XFreqRange, YAmplitude] = sk_dofft(data.Sf(plots_see_chan,:), hdr.S.Fs, 4);
            subplot(3,2,6);plot(XFreqRange, YAmplitude);axis([5 150 -0.2 1.5]);title('The filtered data freq (after bandpass)');
            clear XFreqRange YAmplitude;
        end
    else
        fprintf('Data filtering not done.\n');
        data.Sf = data.S;
        data.Rf = data.R;
    end
    
    %% reject bad channels
    % using cleanraw from the eeglab
    % a) flatline channels
    % b) noisy channels
    % c) short-time bursts
    % d) incompletely repaird segments from the data
    
    S.channels_to_remove = zeros(hdr.S.nChans,1);
    R.channels_to_remove = zeros(hdr.R.nChans,1);
    if wanted.clean_data
        
        fprintf('Cleaning data ...\n');
        
        % find(S.channels_to_remove)'
        % find(R.channels_to_remove)'
        
        % a) flatline channels (based: clean_flatlines)
        fprintf('---Checking and marking for flat-line ...\n');
        max_flatline_duration = 5; % in seconds
        max_allowed_jitter = 20; % as multiples of epsilon
        %
        S.channels_to_remove_flatline = zeros(hdr.S.nChans,1);
        R.channels_to_remove_flatline = zeros(hdr.R.nChans,1);
        temp_S.data = data.Sf;temp_S.srate = hdr.S.Fs;temp_S.nbchan = hdr.S.nChans;
        temp_R.data = data.Rf;temp_R.srate = hdr.R.Fs;temp_R.nbchan = hdr.R.nChans;
        %
        temp_S = sk_clean_flatlines(temp_S,max_flatline_duration,max_allowed_jitter);
        temp_R = sk_clean_flatlines(temp_R,max_flatline_duration,max_allowed_jitter);
        %
        S.channels_to_remove_flatline = temp_S.removed_channels;
        R.channels_to_remove_flatline = temp_R.removed_channels;
        clear temp_A temp_B
        fprintf('---Checking and marking for flat-line channels ... Done.\n');
        
        
        % b) noisy channels (remove noisy channels by correlation and line-noise thresholds) (based: clean_channels)
        fprintf('---Checking and marking for noisy channels ...\n');
        min_corr = 0.45; % minimum correlation
        ignored_quantile = 0.1; % check the function description
        window_len = 2; % in seconds
        max_broken_time = 0.5; % in seconds
        linenoise_aware = true; % if there is line noise
        %
        S.channels_to_remove_noisy = zeros(hdr.S.nChans,1);
        R.channels_to_remove_noisy = zeros(hdr.R.nChans,1);
        temp_S.data = data.Sf;temp_S.srate = hdr.S.Fs;temp_S.nbchan = hdr.S.nChans;
        temp_R.data = data.Rf;temp_R.srate = hdr.R.Fs;temp_R.nbchan = hdr.R.nChans;
        %
        temp_S = sk_clean_channels_nolocs(temp_S,min_corr,ignored_quantile,window_len,max_broken_time,linenoise_aware);
        temp_R = sk_clean_channels_nolocs(temp_R,min_corr,ignored_quantile,window_len,max_broken_time,linenoise_aware);
        % flag channels to be implemented
        S.channels_to_remove_noisy = temp_S.removed_channels;
        R.channels_to_remove_noisy = temp_R.removed_channels;
        clear temp_A temp_B
        %
        fprintf('---Checking and marking for noisy channels ... Done.\n');
        %
        
        %%% Here, remove the bad channels before the ASR and the clean windows
        fprintf('Removing the bad channels before the ASR ...\n');
        S.channels_to_remove =  S.channels_to_remove_bridge | S.channels_to_remove_flatline' | S.channels_to_remove_noisy;
        R.channels_to_remove = R.channels_to_remove_bridge | R.channels_to_remove_flatline' | R.channels_to_remove_noisy;
        %
        data.Sf_cut = data.Sf(~S.channels_to_remove,:);
        data.Rf_cut = data.Rf(~R.channels_to_remove,:);
        fprintf('Removing the bad channels before the ASR ... Done.\n');
        %%%
        
        % c) short-time bursts (based: clean_asr)
        fprintf('---Implementing the artifact sub-space reconstruction (ASR) for short time bursts ...\n');
        % use the defaults
        temp_S.data = data.Sf_cut;temp_S.srate = hdr.S.Fs;temp_S.nbchan = size(data.Sf_cut,1);
        temp_R.data = data.Rf_cut;temp_R.srate = hdr.R.Fs;temp_R.nbchan = size(data.Rf_cut,1);
        %
        temp_S = sk_clean_asr(temp_S);
        temp_R = sk_clean_asr(temp_R);
        %
        data.Sf_cut_asr =  temp_S.data;
        data.Rf_cut_asr =  temp_R.data;
        clear temp_A temp_B
        fprintf('---Implementing the artifact sub-space reconstruction (ASR) for short time bursts ... Done.\n');
        
        % d) incompletely repaird segments from the data
        % use asr data, not filtered data ()
        fprintf('---Remove periods with abnormally high-power content from continuous data ...\n');
        window_crit = 0.25;
        window_crit_tolerances = [-inf 7];
        %
        temp_S.data = data.Sf_cut_asr;temp_S.srate = hdr.S.Fs;temp_S.nbchan = size(data.Sf_cut,1);
        temp_R.data = data.Rf_cut_asr;temp_R.srate = hdr.R.Fs;temp_R.nbchan = size(data.Rf_cut,1);
        %
        temp_S = sk_clean_windows(temp_S,window_crit,window_crit_tolerances);
        temp_R = sk_clean_windows(temp_R,window_crit,window_crit_tolerances);
        %
        data.Sf_cut_asr_repaired =  temp_S.data;
        data.Rf_cut_asr_repaired =  temp_R.data;
        clear temp_A temp_B
        fprintf('---Remove periods with abnormally high-power content from continuous data ... Done.\n');
        %
        
    else
        fprintf('Data cleaning not done.\n');
        data.Sf_cut_asr_repaired = data.Sf;
        data.Rf_cut_asr_repaired = data.Rf;
    end
    
    
    %% interpolating the missing channels
    % Interpolate channels. (not ideal before ICA, but better for re-referencing)
    % get EOG channels
    S.channels_eog =  zeros(hdr.S.nChans,1);
    R.channels_eog =  zeros(hdr.R.nChans,1);
    S.channels_eog(contains(hdr.S.label,'EX')) = 1;
    R.channels_eog(contains(hdr.R.label,'EX')) = 1;
    %
    fprintf('---Interpolating missing channels for the re-referencing part ....\n');
    % add fake channels with zeros that need to be interpolated
    data.S_temp_interp = zeros(hdr.S.nChans,size(data.Sf_cut_asr_repaired,2));
    [f_idx,~]=find(S.channels_to_remove);
    count_chan = 1;
    for loop_fake_chan  =1:hdr.S.nChans
        if ~any(loop_fake_chan == f_idx)
            data.S_temp_interp(loop_fake_chan,:) = data.Sf_cut_asr_repaired(count_chan,:);
            count_chan = count_chan+1;
        end
    end
    clear f_idx count_chan loop_fake_chan
    data.R_temp_interp = zeros(hdr.R.nChans,size(data.Rf_cut_asr_repaired,2));
    [f_idx,~]=find(R.channels_to_remove);
    count_chan = 1;
    for loop_fake_chan  =1:hdr.R.nChans
        if ~any(loop_fake_chan == f_idx)
            data.R_temp_interp(loop_fake_chan,:) = data.Rf_cut_asr_repaired(count_chan,:);
            count_chan = count_chan+1;
        end
    end
    clear f_idx count_chan loop_fake_chan
    
    % remove the channels that have EOG
    data.S_temp_interp = data.S_temp_interp(~S.channels_eog,:);
    data.R_temp_interp = data.R_temp_interp(~R.channels_eog,:);
    % note the bad channels except the EOG for interpolation
    bad_chans_S = S.channels_to_remove(~S.channels_eog)'; [~,bad_chans_S]= find(bad_chans_S);
    bad_chans_R = R.channels_to_remove(~R.channels_eog)'; [~,bad_chans_R]= find(bad_chans_R);
    % get electrode positions
%     filename.elec = '128 EQ A on MNI average head with ABCD labels for BESA.sfp';
    filename.elec = '128 EQ A on MNI Colin27 with ABCD labels for BESA.sfp';
    elec = readlocs(filename.elec);
    EEG.chanlocs = elec(4:end);
    %
    method = 'spherical';
    %'
    EEG.trials = 1; % no trials
    EEG.data = data.S_temp_interp;
    EEG.nbchan = size(data.S_temp_interp,1);
    EEG.pnts = size(data.Sf_cut_asr_repaired,2);
    S.EEG_interp = sk_eeg_interp(EEG, bad_chans_S, method); % main function
    %
    EEG.trials = 1; % no trials
    EEG.data = data.R_temp_interp;
    EEG.nbchan = size(data.R_temp_interp,1);
    EEG.pnts = size(data.Rf_cut_asr_repaired,2);
    R.EEG_interp = sk_eeg_interp(EEG, bad_chans_R, method); % main function
    %
    data.Sf_cut_asr_repaired_interp = S.EEG_interp.data;
    data.Rf_cut_asr_repaired_interp = R.EEG_interp.data;
    clear EEG method
    fprintf('---Interpolating missing channels for the re-referencing part ... Done.\n');
    
    %% Re-referencing
    if wanted.rereferencing
        fprintf('re-referenciong the data to the common average reference (CAR)...\n');
        mean_data_one = mean(S.EEG_interp.data,1);
        mean_data_two = mean(R.EEG_interp.data,1);
        S.EEG_interp.data_car = S.EEG_interp.data - repmat(mean_data_one,size(S.EEG_interp.data,1),1);
        R.EEG_interp.data_car = R.EEG_interp.data - repmat(mean_data_two,size(R.EEG_interp.data,1),1);
        data.Sf_cut_asr_repaired_interp_car = S.EEG_interp.data_car;
        data.Rf_cut_asr_repaired_interp_car = R.EEG_interp.data_car;
        clear mean_data_one mean_data_two
        fprintf('re-referenciong the data to the common average reference (CAR)... Done.\n');
    else
        fprintf('Re-referenciong not done.\n');
        data.Sf_cut_asr_repaired_interp_car = data.Sf_cut_asr_repaired_interp;
        data.Rf_cut_asr_repaired_interp_car = data.Rf_cut_asr_repaired_interp;
        S.EEG_interp.data_car = S.EEG_interp.data;
        R.EEG_interp.data_car = R.EEG_interp.data;
    end
    
    
    %% remove the interpolated channels before ICA
    data.Sf_cut_asr_repaired_interp_car_cut = S.EEG_interp.data_car(~S.channels_to_remove(~S.channels_eog),:);
    data.Rf_cut_asr_repaired_interp_car_cut = R.EEG_interp.data_car(~R.channels_to_remove(~R.channels_eog),:);
    
    %% now the ICA
    if wanted.ica
        %
        if strcmp(wanted.ica_algorithm,'amica')
            fprintf('performing the ICA using the AMICA algorithm...\n');
            [S.ica.icaweights,S.ica.icasphere,S.ica.mods] = runamica15(data.Sf_cut_asr_repaired_interp_car_cut);
            [R.ica.icaweights,R.ica.icasphere,R.ica.mods] = runamica15(data.Rf_cut_asr_repaired_interp_car_cut);
            fprintf('performing the ICA using the AMICA algorithm... Done.\n');
        elseif strcmp(wanted.ica_algorithm,'runica')
            fprintf('performing the ICA using the runica algorithm...\n');
            [S.ica.icaweights,S.ica.icasphere,S.ica.icameanvar,S.ica.icabias,S.ica.icasigns,S.ica.icalrates,S.ica.icadata,S.ica.icay] = runica(data.Sf_cut_asr_repaired_interp_car_cut); % train using defaults
            [R.ica.icaweights,R.ica.icasphere,R.ica.icameanvar,R.ica.icabias,R.ica.icasigns,R.ica.icalrates,R.ica.icadata,R.ica.icay] = runica(data.Rf_cut_asr_repaired_interp_car_cut); % train using defaults
            fprintf('performing the ICA using the runica algorithm... Done.\n');
        else
            error('Please choose either amica or runica algorithm in the ICA section');
        end
        
        
        %% Auto-detection of bad ICA components
        fprintf('auto detecting the bad ICA components...\n');
        % calculate the inverse of the ica weights
        S.ica.icawinv = pinv(S.ica.icaweights*S.ica.icasphere);
        R.ica.icawinv = pinv(R.ica.icaweights*R.ica.icasphere);
        % other parameters
        S.ica.data = data.Sf_cut_asr_repaired_interp_car_cut;
        S.ica.nbchan = size(S.ica.icaweights,1);
        S.ica.trials = 1;
        S.ica.times = 1:size(S.ica.data,2);
        S.ica.srate = hdr.S.Fs;
        S.ica.icachansind = 1:size(S.ica.data,1);
        R.ica.data = data.Rf_cut_asr_repaired_interp_car_cut;
        R.ica.nbchan = size(R.ica.icaweights,1);
        R.ica.trials = 1;
        R.ica.times = 1:size(R.ica.data,2);
        R.ica.srate = hdr.R.Fs;
        R.ica.icachansind = 1:size(R.ica.data,1);
        %
        temp_channels_to_remove = S.channels_to_remove(~S.channels_eog);
        S.ica.chanlocs = elec(4:end);S.ica.chanlocs = elec(~temp_channels_to_remove);
        S.ica.icaact = S.ica.icaweights*S.ica.icasphere*S.ica.data;
        temp_channels_to_remove = R.channels_to_remove(~R.channels_eog);
        R.ica.chanlocs = elec(4:end);R.ica.chanlocs = elec(~temp_channels_to_remove);
        R.ica.icaact = R.ica.icaweights*R.ica.icasphere*R.ica.data;
        
        % automatic detection of ica components
        cfg = [];
        cfg.autocorr.enable = true;
        cfg.focalcomp.enable = true;
        % cfg.trialfoc.enable = true;
        cfg.SNR.enable = true;
        % cfg.resvar.enable = true; % need dipfit to be done before
        % cfg.EOGcorr.enable = true; % need EOG channels to do this
        % cfg.chancorr.enable = true;
        cfg.ADJUST.enable = true;
        % cfg.FASTER.enable = true;
        % cfg.MARS.Enable = true; % not implememted
        cfg.opts.noplot = 1; % '1' for no plots
        %
        [S.ica_reject, cfg] = sk_eeg_SASICA(S.ica,cfg);
        [R.ica_reject, cfg] = sk_eeg_SASICA(R.ica,cfg);
        %
        % S.ica_reject.reject.gcompreject % to see the components to reject
        % R.ica_reject.reject.gcompreject % to see the components to reject
        fprintf('auto detecting the bad ICA components... Done.\n');
        
        %% Removing the bad ICA components
        fprintf('removing the bad ICA components...\n');
        S.ica_clean.setname = 'ica_clean';
        S.ica_clean.nbchan = S.ica.nbchan;
        S.ica_clean.trials = S.ica.trials;
        S.ica_clean.data = S.ica.data;
        S.ica_clean.pnts = size(S.ica.times,2);
        S.ica_clean.icawinv = S.ica.icawinv;
        S.ica_clean.icasphere = S.ica.icasphere;
        S.ica_clean.icaweights = S.ica.icaweights;
        S.ica_clean.icachansind = S.ica.icachansind;
        if strcmp(wanted.ica_algorithm,'amica')
            S.ica_clean.icaact = S.ica.icaweights*S.ica.icasphere*S.ica.data;  % Matrix multiplication
            R.ica_clean.icaact = R.ica.icaweights*R.ica.icasphere*R.ica.data;  % Matrix multiplication
        elseif strcmp(wanted.ica_algorithm,'runica')
            S.ica_clean.icaact = S.ica.icaweights*S.ica.icasphere*S.ica.icadata;  % Matrix multiplication
            R.ica_clean.icaact = R.ica.icaweights*R.ica.icasphere*R.ica.icadata;  % Matrix multiplication
        else
            error('Please choose either amica or runica algorithm in the ICA section');
        end
        S.ica_clean.reject.gcompreject = S.ica_reject.reject.gcompreject;
        S.ica_clean.reject.SASICA = S.ica_reject.reject.SASICA;
        R.ica_clean.setname = 'ica_clean';
        R.ica_clean.nbchan = R.ica.nbchan;
        R.ica_clean.trials = R.ica.trials;
        R.ica_clean.data = R.ica.data;
        R.ica_clean.pnts = size(R.ica.times,2);
        R.ica_clean.icawinv = R.ica.icawinv;
        R.ica_clean.icasphere = R.ica.icasphere;
        R.ica_clean.icaweights = R.ica.icaweights;
        R.ica_clean.icachansind = R.ica.icachansind;
        R.ica_clean.reject.gcompreject = R.ica_reject.reject.gcompreject;
        R.ica_clean.reject.SASICA = R.ica_reject.reject.SASICA;
        % Extract the Component numbers to remove from the output of SASICA in EEG.reject.gcompreject.  Wherever this is 1, that particular ICA component needs to be removed from the data.
        S.ica_clean.remove_components = find(S.ica_reject.reject.gcompreject == 1);
        R.ica_clean.remove_components = find(R.ica_reject.reject.gcompreject == 1);
        % Remove the components from the main data without further ado!
        S.ica_clean = sk_pop_subcomp(S.ica_clean, S.ica_clean.remove_components);
        R.ica_clean = sk_pop_subcomp(R.ica_clean, R.ica_clean.remove_components);
        fprintf('removing the bad ICA components... Done.\n');
        % ica_clean.data is the cleaned data
        
    else
        fprintf('ICA not done.\n');
    end
    
    %% cut the data here into trials/epochs
    if wanted.trials && wanted.ica
        % the delay between the screens
        events_S = events;
        events_R = events;
        if wanted.photo_diode_trigger_adjustment
            default_screen_delay = 31; % check this value
            default_screen_delay = floor(default_screen_delay/(hdr.both.Fs/wanted.fs_new)); % depending upon the downsampling
            temp_loc = find(strcmp({events.type}, 'STATUS'));
            for loop_status = 1:length(temp_loc)
                events_S(temp_loc(loop_status)).sample = events(temp_loc(loop_status)).sample + default_screen_delay; % check the plus or the minus
            end
            clear loop_status temp_loc
        end
        %
        % for participant A
        sktt = [];
        sktt.Fs = hdr.both.Fs;
        sktt.events = events_S;
        sktt.data = S.ica_clean.data;
        sktt.flag_bc_trial = 1;
        sktt.trig = behave_data.S.ttsk.trig;
        [temp_data, ~] = sk_trials_creation(sktt);
        S.ica_clean_trials = temp_data.trials;
        clear ttsk temp_data
        %
        % for participant B
        sktt = [];
        sktt.Fs = hdr.both.Fs;
        sktt.events = events_S;
        sktt.data = R.ica_clean.data;
        sktt.flag_bc_trial = 1;
        % temporarily interchange the A and B trigger numbers for cutting the
        % data according to the participant B
        temp_trig_R = behave_data.R.ttsk.trig;
        temp_trig_R.response_prediction_A = behave_data.R.ttsk.trig.response_prediction_B;
        temp_trig_R.response_prediction_B = behave_data.R.ttsk.trig.response_prediction_A;
        temp_trig_R.response_choice_A = behave_data.R.ttsk.trig.response_prediction_B;
        temp_trig_R.response_choice_B = behave_data.R.ttsk.trig.response_prediction_A;
        sktt.trig = temp_trig_R;
        [temp_data, ~] = sk_trials_creation(sktt);
        R.ica_clean_trials = temp_data.trials;
        clear ttsk temp_data temp_trig_B
    else
        fprintf('data not cut into trials.\n');
    end
    %
    %% Save the relevent data at this point
    %
    if wanted.save
        fprintf('------ saving the ICA cleaned session ------ and ------ ICA cleaned data in trials. ------ \n');
        if wanted.ica
            temp_save_S.data = S.ica_clean;
            temp_save_R.data = R.ica_clean;
        end
        if wanted.trials
            temp_save_S.trials = S.ica_clean_trials;
            temp_save_R.trials = R.ica_clean_trials;
        end
        temp_save_S.original = data.S;
        temp_save_R.original = data.R;
        temp_save_S.hdr = hdr.S;
        temp_save_R.hdr = hdr.R;
        if wanted.trials && wanted.ica
            temp_save_S.Events = events_S;
            temp_save_R.Events = events_R;
            temp_save_S.photo_diode_delay = default_screen_delay;
            temp_save_R.photo_diode_delay = default_screen_delay;
        end
        temp_save_S.settings = wanted;
        temp_save_R.settings = wanted;
        temp_save_S.behaviour = behave_data.S;
        temp_save_R.behaviour = behave_data.R;
        temp_save_S.Elec = elec;
        temp_save_R.Elec = elec;
        temp_save_S.bad_chans = bad_chans_S;
        temp_save_R.bad_chans = bad_chans_R;
        if wanted.photo_diode_trigger_adjustment
            temp_save_S.photo_diode_delay = diode_avg.default;
            temp_save_R.photo_diode_delay = diode_avg.default;
        end
        temp_save_S.name = strcat('tt_preprocessed_',strcat('_',datestr(now,'YYYYmmDD'),'_',datestr(now,'HHMMSS'),'_'),...
            '_vp',tcg.sub_S,'.mat');
        temp_save_R.name = strcat('tt_preprocessed_',strcat('_',datestr(now,'YYYYmmDD'),'_',datestr(now,'HHMMSS'),'_'),...
            '_vp',tcg.sub_R,'.mat');
        save(temp_save_S.name,'temp_save_S', '-v7.3');
        save(temp_save_R.name,'temp_save_R', '-v7.3');
        fprintf('------ saving the ICA cleaned session ------ and ------ ICA cleaned data in trials. ------ Done.\n');
    else
        fprintf('data not saved.\n');
    end
    %
    %%
    fprintf('\n');
    toc;
    diary('off');
catch exception
    fprintf('\nlogging stopped because of error.\n');
    toc;
    diary('off');
    rethrow(exception);
end

%%
